import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
import numpy as np


""" If R is large and K is small, increase alpha from very small values 
    and the energy will continue to converge until, rather reaching a 
    minimal then going back up, one gets a failure in convergence"""

""" If R is small and K is large (highly converged reciprocal-space sum), 
    one sees clear convergence in the total energy as alpha is increased
    and a greater percentage of the summation is done in reciprocal space"""

""" The tolerance is defined as the accuracy in the real-space part of the sum.
     erfc(sqrt(alpha)*R)/R decreases with increasing alpha. 
     In general, as Rcut is increased =>  erfc(sqrt(alpha)*Rcut)/Rcut
     decreases. That is, the contributions to the real space sum drop off with 
     increasing real-space cutoff. 
     
     One should go as large as is reasonable with Rcut then it's possible, for a fixed
     alpha, to converge the reciprocal space sum and therefore the total energy.
     
     The error in the total energy is given ~ by erfc(sqrt(alpha)*Rcut)/Rcut.
    Although in principle, one should also account for the charges in this expression. """

"""  Our current way of automating the values for alpha and Kmax are wrong
     because our real-space sum is modified w.r.t erfc(sqrt(alpha)*R)/R"""

def smallR_largeK():
    lowr_sweep = \
        [[5, 20, 0.01, -18.708445557788128],
         [5, 20, 0.02, -18.70844556618209],
         [5, 20, 0.05, -18.708450349779007],
         [5, 20, 0.1, -18.708926321484252],
         [5, 20, 0.512, -18.8144059097147],
         [5, 20, 0.5248, -18.814446534817833],
         [5, 20, 0.5376, -18.814474101798204],
         [5, 20, 0.5504, -18.814492628848075],
         [5, 20, 0.5632, -18.814504961739463],
         [5, 20, 0.5760, -18.81451309339529],
         [5, 20, 0.5888, -18.814518404176624],
         [5, 20, 0.6016, -18.814521839836807],
         [5, 20, 0.6144, -18.81452404144084],
         [5, 20, 0.6272, -18.81452543893126],
         [5, 20, 0.64, -18.8145263176327],
         [5, 20, 0.6528, -18.814526864923696],
         [5, 20, 0.6656, -18.814527202584593],
         [5, 20, 0.6784, -18.814527408946443],
         [5, 20, 0.6912, -18.814527533875864],
         [5, 20, 0.704, -18.814527608793977],
         [5, 20, 0.7168, -18.814527653297656],
         [5, 20, 0.7296, -18.814527679485128],
         [5, 20, 0.7424, -18.81452769474941],
         [5, 20, 0.7552, -18.81452770356287],
         [5, 20, 0.768, -18.81452770860373],
         [5, 20, 1.0, -18.8145277150195],
         [5, 20, 2.0, -18.814527715027086]]

    x = []
    y = []
    for point in lowr_sweep:
        y.append(point[3])
        x.append(point[2])

    # For a small, real-space cut-off:
    # As one moves to larger broadenings, for a converged choice of k_max
    # one sees covergence in the total energy
    # Remove very unconverged values, 0:3
    plt.plot(x[4:], y[4:], 'ro--')
    plt.show()


def largeR_smallK():
    lowk_sweep = \
        [[20, 1, 0.01, -18.757652327759725],
         [20, 1, 0.02, -18.757652546681914],
         [20, 1, 0.05, -18.7576940285406],
         [20, 1, 0.1, -18.757837320704006],
         [20, 1, 0.128, -18.757842228703172],
         [20, 1, 0.1312, -18.757842841814487],
         [20, 1, 0.1344, -18.757843717618247],
         [20, 1, 0.1376, -18.75784501990618],
         [20, 1, 0.1408, -18.7578469950167],
         [20, 1, 0.1440, -18.75785000438695],
         [20, 1, 0.1472, -18.75785456316075],
         [20, 1, 0.1504, -18.757861383884027],
         [20, 1, 0.1536, -18.75787142370643],
         [20, 1, 0.1568, -18.757885933034895],
         [20, 1, 0.16, -18.75790650329679],
         [20, 1, 0.1632, -18.757935111384274],
         [20, 1, 0.1664, -18.757974158462257],
         [20, 1, 0.1696, -18.758026501103366],
         [20, 1, 0.1728, -18.758095473129465],
         [20, 1, 0.176, -18.75818489704136],
         [20, 1, 0.1792, -18.758299084462703],
         [20, 1, 0.1824, -18.75844282556575],
         [20, 1, 0.1856, -18.758621367947622],
         [20, 1, 0.1888, -18.75884038585871],
         [20, 1, 0.192, -18.75910594102953]]
    # [20, 1, 0.5 0
    # [20, 1, 1.0 -438.56718668789915
    # [20, 1, 2.0 -917.2590545089627

    x = []
    y = []
    for point in lowk_sweep:
        y.append(point[3])
        x.append(point[2])

    # Again, remove erroneous points. As soon as one goes to large
    # broadening, hence reciprocal-space contribution, the total energy fails to
    # converge. This makes sense as the reciprocal-space sum is high unconverged
    # What I find surprising is that it continues to get lower in energy as alpha increases
    # until the point of failure in covergence
    plt.plot(x, y, 'ro--')
    plt.show()











quit()

# Maybe the issue is that both k and real are extremely well converged
# Do this with a much smaller real and k, of say (5,10) and (20,1)
sweep_data = \
[
[20, 20, 0.01,   -18.757652327759725],
[20, 20, 0.1280, -18.757842015515106],
[20, 20, 0.1312, -18.75784238926189],
[20, 20, 0.1344, -18.757842806648146],
[20, 20, 0.1376, -18.757843272518954],
[20, 20, 0.1408, -18.75784378721845],
[20, 20, 0.1440, -18.75784434676557],
[20, 20, 0.1472, -18.757844943368912],
[20, 20, 0.1504, -18.757845566264375],
[20, 20, 0.1536, -18.7578462027748],
[20, 20, 0.1568, -18.757846839452473],
[20, 20, 0.1600, -18.75784746316505],
[20, 20, 0.1632, -18.757848062013096],
[20, 20, 0.1664, -18.757848626008332],
[20, 20, 0.1696, -18.757849147484542],
[20, 20, 0.1728, -18.7578496212513],
[20, 20, 0.1760, -18.757850044527164],
[20, 20, 0.1792, -18.757850416705256],
[20, 20, 0.1824, -18.75785073900886],
[20, 20, 0.1856, -18.757851014091607],
[20, 20, 0.1888, -18.757851245628807],
[20, 20, 0.1920, -18.7578514379344],
 [20, 20, 0.5,    -18.75785216402768],
 [20, 20, 1,      -18.75785216402769],
 [20, 20, 2,      -18.75785216403469],
 [20, 20, 3,      -18.757869087399417],
 [20, 20, 4,      -18.7616471096065]]

x = []
y = []
for point in sweep_data:
    y.append(point[2])
    x.append(point[3])


plt.plot(x,y)
plt.show()
quit()


data_20 = \
[[20, 1, 0.01, -18.757652327759725],
[20, 1, 0.02, -18.757652546681914],
[20, 1, 0.05, -18.7576940285406],
[20, 1, 0.1 ,-18.757837320704006],
[20, 1, 0.2 ,-18.760016150317146],
[20, 1, 0.3 ,-18.840314462327875],
[20, 1, 0.4 ,-19.110084432783896],
[20, 1, 0.5 , 0],
[20, 1, 1   , -438.56718668789915],
[20, 2, 0.01 ,-18.757652327759725],
[20, 2, 0.02 ,-18.757652546681914],
[20, 2, 0.05 ,-18.7576940285406],
[20, 2, 0.1 ,-18.75783732069406],
[20, 2, 0.2 ,-18.757851777398614],
[20, 2, 0.3 ,-18.75785217329028],
[20, 2, 0.4 ,-18.757876967310246],
[20, 2, 0.5 ,-18.758854265773614],
[20, 2, 1   , -286.09181101256706],
[20, 3, 0.01, -18.757652327759725],
[20, 3, 0.02, -18.757652546681914],
[20, 3, 0.05, -18.7576940285406],
[20, 3, 0.1 ,-18.75783732069406],
[20, 3, 0.2 ,-18.757851777398606],
[20, 3, 0.3 ,-18.757852164029906],
[20, 3, 0.4 ,-18.757852491761145],
[20, 3, 0.5 ,-18.757914091161926],
[20, 3, 1   ,-18.88236002718155],
[20, 4, 0.01, -18.757652327759725],
[20, 4, 0.02, -18.757652546681914],
[20, 4, 0.05, -18.7576940285406],
[20, 4, 0.1 ,-18.75783732069406],
[20, 4, 0.2 ,-18.757851777398606],
[20, 4, 0.3 ,-18.757852164025483],
[20, 4, 0.4 ,-18.757852164028407],
[20, 4, 0.5 ,-18.757852177777643],
[20, 4, 1   ,-18.76956316815398],
[20, 6, 0.01, -18.757652327759725],
[20, 6, 0.02, -18.757652546681914],
[20, 6, 0.05, -18.7576940285406],
[20, 6, 0.1 ,-18.75783732069406],
[20, 6, 0.2 ,-18.757851777398606],
[20, 6, 0.3 ,-18.757852164025483],
[20, 6, 0.4 ,-18.757852164027682],
[20, 6, 0.5 ,-18.757852164027675],
[20, 6, 1   ,-18.757913667381732],
[20, 8, 0.01, -18.757652327759725],
[20, 8, 0.02, -18.757652546681914],
[20, 8, 0.05, -18.7576940285406],
[20, 8, 0.1 ,-18.75783732069406],
[20, 8, 0.2 ,-18.757851777398606],
[20, 8, 0.3 ,-18.757852164025483],
[20, 8, 0.4 ,-18.757852164027682],
[20, 8, 0.5 ,-18.75785216402768],
[20, 8, 1   ,-18.757852191030352],
[20, 10, 0.01, -18.757652327759725],
[20, 10, 0.02, -18.757652546681914],
[20, 10, 0.05, -18.7576940285406],
[20, 10, 0.1 ,-18.75783732069406],
[20, 10, 0.2 ,-18.757851777398606],
[20, 10, 0.3 ,-18.757852164025483],
[20, 10, 0.4 ,-18.757852164027682],
[20, 10, 0.5 ,-18.75785216402768],
[20, 10, 1   ,-18.757852164031526]]

fig = plt.figure()
ax = fig.gca(projection='3d')





# CAN"T HACK< LOOK TO DO PROPERLY

X = [1, 2, 3, 4, 6, 8, 10]
Y = [0.01, 0.02, 0.05, 0.1, 0.2, 0.3, 0.4, 0.5, 1]
X, Y = np.meshgrid(X, Y)

z = []
for entry in data_20:
    z.append(entry[3])

Z = np.zeros(shape=(9,7))
cnt = 0
for j in range(0, 7):
    for i in range(0, 9):
        Z[i,j] = z[cnt]
        cnt += 1

print(X.shape, Z.shape)

# Plot the surface.
surf = ax.plot_surface(X, Y, Z)



plt.show()
